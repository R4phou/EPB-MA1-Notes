## Logic circuit simulation
We want to **simulate a concurrent behavior of a digital logic circuit with a sequential computer**. It is a problem that is not 100% solved.

Let's try it for this circuit:
![](Pasted%20image%2020231012155006.png)
Let's imagine that the input at the instance dev1 switches from 1 to 0. Logic value at A should change and propagate through instance dev3 and dev2 to reach B and C. 
$\to$ But since the computer is **sequential**, *only one gate could be evaluated at a time*. We should then pick between dev2 or dev3. We need to **decide the order in which the gates will be evaluated**. If the order is wrong, the results will be too.
![](Pasted%20image%2020231012155452.png)
### Solution
#logic-circuit #simulation 
Implement and execute on the computer an **event based simulation**:
- Attach a separate piece of executing SW to each component of the HW
- Each piece is evaluated/triggered if its input changes #event and will be processed accordingly by the simulator
- After evaluation of this single functionality, different outputs generated by this gate are stored and processed to eventually become **events** **to trigger other pieces** of software.
### Delta delays
We don't know how much evaluations will be needed, therefore the simulation needs to be **flexible**. This flexible *rubber time* is handled by using #delta-delay ($\Delta-$delay). This is an *infinitesimal time interval in which future assignments are done*. It's just a way to discretise time internally in the simulator and enable event base simulation with as many steps as needed to produce the right simulation value. We also talk of #delta-cycle.
### Event based simulation with $\Delta-$cycles
If the input changes, it triggers a simulation relative to INV, producing the output change scheduled for the next #delta-cycle. The inverter process is suspended since no events on the input, so we move to the next $\Delta-$cycle.

During the next cycle, either dev2 or dev3 can execute:
- if dev3 is first (NAND): next cycle updates the value of C
- if dev2 is first, dev3 process re-triggers dev2 in the next cycle since there is an event on B.
![](Pasted%20image%2020231012164053.png)
## In real circuits
In the real circuit, after some time of electrical transient things should and will settle to the right value. We just **have to wait for a certain time** to get the **output stabilised**.

$\to$ Digital circuits too but they are not subject to race conditions.
## Circuits and simulation - computer pov
To simulate digital circuits we need some kind of mechanism to emulate concurrent systems: **event based simulation and delta-cycles**.

When simulating HW, we do not use typical SW process and threads since their control is not flexible. Rather **any HW simulator will implement itâ€™s own notion of HW process/thread**.

These HW processes will be controlled by the **simulation kernel**. By "executed": the SW model by the simulation kernel running on the top of an OS. #Simulation-kernel is responsible of *launching, suspending, and scheduling* of all *processes* that are describing our HW system.
### Processes and event based simulation
Once the SW view of the HW #process launched, it never ends. They stop only when the simulation ends.

However *in order to serve all processes that describe our system*, **every process is suspended for execution at some point in time**, so that the CPU on which the simulator runs can share his time among all the other processes in the system.

It the process has a #sensitivity-list, the **process will be automatically suspended for execution** when the last statement in that process has been processed by the simulator. And it will **resume**, only if and when **a signal that is described in the sensitivity list changes value**. If not, then the process remains suspended.
## Different signal assignments
In case of #concurrent assignments statements:
- The **change of any signal** that appears on the right-hand side of the assignment symbol **activates the assignment execution**, without specifying a sensitivity list.

In case of #sequential assignments statements, the signal assignment is determined by:
- The change of a signal in their sensitivity list or,
- Encountering a *wait* statement

$\to$ Activation of an assignment statement is independent of activation of other concurrent statements within the architecture.

$\to$ As opposed to concurrent assignments, if a **process contains several sequential assignments** to the same signal, **only the last assignment will be effective**!

### Using wait to control process
Instead of a #sensitivity-list, a process can contain a #wait statement. It is an explicit order for the simulator to **suspend the execution** of a process currently in execution and **specify a condition** that will **resume** the suspended process.

Note that sensitivity lists and wait are **mutually exclusive**.
![](Pasted%20image%2020231018104504.png)
#### Wait on
Process is **suspended until some signal change**, this is *equivalent to the use of a sensitivity list* in the process statement.
#### Wait for
Process is **resumed after some user specified amount** of *simulation time* (time_expression). This is not an absolute time, but a **relative** one to some timing referenced that is **defined elsewhere**.
#### Wait until
Process is **resumed** when the **logical condition turns true** due to a change of any signal listed in the condition. 
$\to$ If none of the signals in that expression changes, the process will not be activated, even if the conditional expression is true.
![](Pasted%20image%2020231018104519.png)
1. signal is the name of a signal and value is the value tested
2. Uses Boolean expression
	1. 'event is a predefined signal attribute that is TRUE iff there is an event on signal in current #delta-cycle 
	2. If the signal is of type bit, then if the value tested is '1', the statement will *wait for the rising edge of the signal*.
	3. If the value tested is '0', the statement will wait for the *falling edge* of the signal.
3. 'stable is predefined signal attribute to control the amount of time in which we allow events to be considered as such.
#### Other waits
It is possible to use a wait without condition. It is the equivalent to *wait until true*. Widely used in test benches.
## Synchronous operations
The *wait until* statement is used to model, simulate and implement **synchronous** operation of digital circuits. The signal usually tested is a periodic signal like a #clocks.
![](Pasted%20image%2020231018110212.png)
In this course we use the edge triggered clock.
For models that are to be synthesized (and not only simulated), the *wait until* statement must be the **first statement in the process**.
## Combinatorial or sequential process
When used to model a combinatorial logic for synthesis, a process may contain only one *wait* statement. If the process contains this wait statement, it **cannot contain a sensitivity list**!![](Pasted%20image%2020231018110832.png)
These two models are the same.
